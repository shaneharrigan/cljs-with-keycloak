shadow$provide.module$node_modules$browserify_sign$browser$sign = function(global, require, module, exports) {
  function getKey(x, q, hash, algo) {
    x = Buffer.from(x.toArray());
    if (x.length < q.byteLength()) {
      var zeros = Buffer.alloc(q.byteLength() - x.length);
      x = Buffer.concat([zeros, x]);
    }
    zeros = hash.length;
    hash = bits2int(hash, q);
    hash = hash.mod(q);
    hash = Buffer.from(hash.toArray());
    hash.length < q.byteLength() && (q = Buffer.alloc(q.byteLength() - hash.length), hash = Buffer.concat([q, hash]));
    q = hash;
    hash = Buffer.alloc(zeros);
    hash.fill(1);
    zeros = Buffer.alloc(zeros);
    zeros = createHmac(algo, zeros).update(hash).update(Buffer.from([0])).update(x).update(q).digest();
    hash = createHmac(algo, zeros).update(hash).digest();
    zeros = createHmac(algo, zeros).update(hash).update(Buffer.from([1])).update(x).update(q).digest();
    hash = createHmac(algo, zeros).update(hash).digest();
    return {k:zeros, v:hash};
  }
  function bits2int(obits, q) {
    var bits = new BN(obits);
    obits = (obits.length << 3) - q.bitLength();
    0 < obits && bits.ishrn(obits);
    return bits;
  }
  function makeKey(q, kv, algo) {
    var t;
    do {
      for (t = Buffer.alloc(0); 8 * t.length < q.bitLength();) {
        kv.v = createHmac(algo, kv.k).update(kv.v).digest(), t = Buffer.concat([t, kv.v]);
      }
      t = bits2int(t, q);
      kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest();
      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
    } while (-1 !== t.cmp(q));
    return t;
  }
  var Buffer = require("module$node_modules$safe_buffer$index").Buffer, createHmac = require("module$node_modules$create_hmac$browser"), crt = require("module$node_modules$browserify_rsa$index"), EC = require("module$node_modules$elliptic$lib$elliptic").ec, BN = require("module$node_modules$bn_DOT_js$lib$bn"), parseKeys = require("module$node_modules$parse_asn1$index"), curves = require("module$node_modules$browserify_sign$browser$curves_json");
  module.exports = function(hash$jscomp$0, key, hashType, signType, tag) {
    var priv = parseKeys(key);
    if (priv.curve) {
      if ("ecdsa" !== signType && "ecdsa/rsa" !== signType) {
        throw Error("wrong private key type");
      }
      hashType = hash$jscomp$0;
      hash$jscomp$0 = curves[priv.curve.join(".")];
      if (!hash$jscomp$0) {
        throw Error("unknown curve " + priv.curve.join("."));
      }
      hashType = (new EC(hash$jscomp$0)).keyFromPrivate(priv.privateKey).sign(hashType);
      return Buffer.from(hashType.toDER());
    }
    if ("dsa" === priv.type) {
      if ("dsa" !== signType) {
        throw Error("wrong private key type");
      }
      var hash = hash$jscomp$0;
      hash$jscomp$0 = priv.params.priv_key;
      key = priv.params.p;
      signType = priv.params.q;
      priv = priv.params.g;
      var r = new BN(0);
      tag = bits2int(hash, signType).mod(signType);
      var k = !1;
      for (hash = getKey(hash$jscomp$0, signType, hash, hashType); !1 === k;) {
        r = k = makeKey(signType, hash, hashType);
        var q = signType;
        r = priv.toRed(BN.mont(key)).redPow(r).fromRed().mod(q);
        k = k.invm(signType).imul(tag.add(hash$jscomp$0.mul(r))).mod(signType);
        0 === k.cmpn(0) && (k = !1, r = new BN(0));
      }
      hashType = k;
      priv = r.toArray();
      hashType = hashType.toArray();
      priv[0] & 128 && (priv = [0].concat(priv));
      hashType[0] & 128 && (hashType = [0].concat(hashType));
      hash$jscomp$0 = [48, priv.length + hashType.length + 4, 2, priv.length];
      hash$jscomp$0 = hash$jscomp$0.concat(priv, [2, hashType.length], hashType);
      return Buffer.from(hash$jscomp$0);
    }
    if ("rsa" !== signType && "ecdsa/rsa" !== signType) {
      throw Error("wrong private key type");
    }
    if (void 0 !== key.padding && 1 !== key.padding) {
      throw Error("illegal or unsupported padding mode");
    }
    hash$jscomp$0 = Buffer.concat([tag, hash$jscomp$0]);
    key = priv.modulus.byteLength();
    for (hashType = [0, 1]; hash$jscomp$0.length + hashType.length + 1 < key;) {
      hashType.push(255);
    }
    hashType.push(0);
    for (key = -1; ++key < hash$jscomp$0.length;) {
      hashType.push(hash$jscomp$0[key]);
    }
    return crt(hashType, priv);
  };
  module.exports.getKey = getKey;
  module.exports.makeKey = makeKey;
};

//# sourceMappingURL=module$node_modules$browserify_sign$browser$sign.js.map
