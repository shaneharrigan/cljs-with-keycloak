shadow$provide.module$node_modules$elliptic$lib$elliptic$utils = function(global, require, module, exports) {
  var BN = require("module$node_modules$elliptic$node_modules$bn_js$lib$bn");
  global = require("module$node_modules$minimalistic_assert$index");
  require = require("module$node_modules$minimalistic_crypto_utils$lib$utils");
  exports.assert = global;
  exports.toArray = require.toArray;
  exports.zero2 = require.zero2;
  exports.toHex = require.toHex;
  exports.encode = require.encode;
  exports.getNAF = function(num, w, bits) {
    bits = Array(Math.max(num.bitLength(), bits) + 1);
    var i;
    for (i = 0; i < bits.length; i += 1) {
      bits[i] = 0;
    }
    w = 1 << w + 1;
    num = num.clone();
    for (i = 0; i < bits.length; i++) {
      var z = num.andln(w - 1);
      num.isOdd() ? (z = z > (w >> 1) - 1 ? (w >> 1) - z : z, num.isubn(z)) : z = 0;
      bits[i] = z;
      num.iushrn(1);
    }
    return bits;
  };
  exports.getJSF = function(k1, k2) {
    var jsf = [[], []];
    k1 = k1.clone();
    k2 = k2.clone();
    for (var d1 = 0, d2 = 0, m8; 0 < k1.cmpn(-d1) || 0 < k2.cmpn(-d2);) {
      var m14 = k1.andln(3) + d1 & 3, m24 = k2.andln(3) + d2 & 3;
      3 === m14 && (m14 = -1);
      3 === m24 && (m24 = -1);
      if (0 === (m14 & 1)) {
        var u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7, u1 = 3 !== m8 && 5 !== m8 || 2 !== m24 ? m14 : -m14;
      }
      jsf[0].push(u1);
      0 === (m24 & 1) ? m8 = 0 : (m8 = k2.andln(7) + d2 & 7, m8 = 3 !== m8 && 5 !== m8 || 2 !== m14 ? m24 : -m24);
      jsf[1].push(m8);
      2 * d1 === u1 + 1 && (d1 = 1 - d1);
      2 * d2 === m8 + 1 && (d2 = 1 - d2);
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  };
  exports.cachedProperty = function(obj, name, computer) {
    var key = "_" + name;
    obj.prototype[name] = function() {
      return void 0 !== this[key] ? this[key] : this[key] = computer.call(this);
    };
  };
  exports.parseBytes = function(bytes) {
    return "string" === typeof bytes ? exports.toArray(bytes, "hex") : bytes;
  };
  exports.intFromLE = function(bytes) {
    return new BN(bytes, "hex", "le");
  };
};

//# sourceMappingURL=module$node_modules$elliptic$lib$elliptic$utils.js.map
