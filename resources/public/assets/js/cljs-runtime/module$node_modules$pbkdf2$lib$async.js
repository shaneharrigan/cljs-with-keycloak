shadow$provide.module$node_modules$pbkdf2$lib$async = function(global, require, module, exports) {
  function checkNative(algo) {
    if (global.process && !global.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits) {
      return Promise.resolve(!1);
    }
    if (void 0 !== checks[algo]) {
      return checks[algo];
    }
    ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
    var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return checks[algo] = prom;
  }
  function getNextTick() {
    return nextTick ? nextTick : nextTick = global.process && global.process.nextTick ? global.process.nextTick : global.queueMicrotask ? global.queueMicrotask : global.setImmediate ? global.setImmediate : global.setTimeout;
  }
  function browserPbkdf2(password, salt, iterations, length, algo) {
    return subtle.importKey("raw", password, {name:"PBKDF2"}, !1, ["deriveBits"]).then(function(key) {
      return subtle.deriveBits({name:"PBKDF2", salt, iterations, hash:{name:algo}}, key, length << 3);
    }).then(function(res) {
      return Buffer.from(res);
    });
  }
  function resolvePromise(promise, callback) {
    promise.then(function(out) {
      getNextTick()(function() {
        callback(null, out);
      });
    }, function(e) {
      getNextTick()(function() {
        callback(e);
      });
    });
  }
  var Buffer = require("module$node_modules$safe_buffer$index").Buffer, checkParameters = require("module$node_modules$pbkdf2$lib$precondition"), defaultEncoding = require("module$node_modules$pbkdf2$lib$default_encoding"), sync = require("module$node_modules$pbkdf2$lib$sync_browser"), toBuffer = require("module$node_modules$pbkdf2$lib$to_buffer"), ZERO_BUF, subtle = global.crypto && global.crypto.subtle, toBrowser = {sha:"SHA-1", "sha-1":"SHA-1", sha1:"SHA-1", sha256:"SHA-256", "sha-256":"SHA-256", 
  sha384:"SHA-384", "sha-384":"SHA-384", "sha-512":"SHA-512", sha512:"SHA-512"}, checks = [], nextTick;
  module.exports = function(password, salt, iterations, keylen, digest, callback) {
    "function" === typeof digest && (callback = digest, digest = void 0);
    digest = digest || "sha1";
    var algo = toBrowser[digest.toLowerCase()];
    if (algo && "function" === typeof global.Promise) {
      checkParameters(iterations, keylen);
      password = toBuffer(password, defaultEncoding, "Password");
      salt = toBuffer(salt, defaultEncoding, "Salt");
      if ("function" !== typeof callback) {
        throw Error("No callback provided to pbkdf2");
      }
      resolvePromise(checkNative(algo).then(function(resp) {
        return resp ? browserPbkdf2(password, salt, iterations, keylen, algo) : sync(password, salt, iterations, keylen, digest);
      }), callback);
    } else {
      getNextTick()(function() {
        try {
          var out = sync(password, salt, iterations, keylen, digest);
        } catch (e) {
          return callback(e);
        }
        callback(null, out);
      });
    }
  };
};

//# sourceMappingURL=module$node_modules$pbkdf2$lib$async.js.map
