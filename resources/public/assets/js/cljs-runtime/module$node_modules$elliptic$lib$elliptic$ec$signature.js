shadow$provide.module$node_modules$elliptic$lib$elliptic$ec$signature = function(global, require, module, exports) {
  function Signature(options, enc) {
    if (options instanceof Signature) {
      return options;
    }
    this._importDER(options, enc) || (assert(options.r && options.s, "Signature without r or s"), this.r = new BN(options.r, 16), this.s = new BN(options.s, 16), this.recoveryParam = void 0 === options.recoveryParam ? null : options.recoveryParam);
  }
  function Position() {
    this.place = 0;
  }
  function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 128)) {
      return initial;
    }
    initial &= 15;
    if (0 === initial || 4 < initial) {
      return !1;
    }
    for (var val = 0, i = 0, off = p.place; i < initial; i++, off++) {
      val <<= 8, val |= buf[off], val >>>= 0;
    }
    if (127 >= val) {
      return !1;
    }
    p.place = off;
    return val;
  }
  function rmPadding(buf) {
    for (var i = 0, len = buf.length - 1; !(buf[i] || buf[i + 1] & 128) && i < len;) {
      i++;
    }
    return 0 === i ? buf : buf.slice(i);
  }
  function constructLength(arr, len) {
    if (!(128 > len)) {
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      for (arr.push(octets | 128); --octets;) {
        arr.push(len >>> (octets << 3) & 255);
      }
    }
    arr.push(len);
  }
  var BN = require("module$node_modules$elliptic$node_modules$bn_js$lib$bn"), utils = require("module$node_modules$elliptic$lib$elliptic$utils"), assert = utils.assert;
  module.exports = Signature;
  Signature.prototype._importDER = function(data, enc) {
    data = utils.toArray(data, enc);
    enc = new Position();
    if (48 !== data[enc.place++]) {
      return !1;
    }
    var len = getLength(data, enc);
    if (!1 === len || len + enc.place !== data.length || 2 !== data[enc.place++]) {
      return !1;
    }
    var rlen = getLength(data, enc);
    if (!1 === rlen) {
      return !1;
    }
    len = data.slice(enc.place, rlen + enc.place);
    enc.place += rlen;
    if (2 !== data[enc.place++]) {
      return !1;
    }
    rlen = getLength(data, enc);
    if (!1 === rlen || data.length !== rlen + enc.place) {
      return !1;
    }
    data = data.slice(enc.place, rlen + enc.place);
    if (0 === len[0]) {
      if (len[1] & 128) {
        len = len.slice(1);
      } else {
        return !1;
      }
    }
    if (0 === data[0]) {
      if (data[1] & 128) {
        data = data.slice(1);
      } else {
        return !1;
      }
    }
    this.r = new BN(len);
    this.s = new BN(data);
    this.recoveryParam = null;
    return !0;
  };
  Signature.prototype.toDER = function(enc) {
    var r = this.r.toArray(), s = this.s.toArray();
    r[0] & 128 && (r = [0].concat(r));
    s[0] & 128 && (s = [0].concat(s));
    r = rmPadding(r);
    for (s = rmPadding(s); !(s[0] || s[1] & 128);) {
      s = s.slice(1);
    }
    var arr = [2];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(2);
    constructLength(arr, s.length);
    r = arr.concat(s);
    s = [48];
    constructLength(s, r.length);
    s = s.concat(r);
    return utils.encode(s, enc);
  };
};

//# sourceMappingURL=module$node_modules$elliptic$lib$elliptic$ec$signature.js.map
