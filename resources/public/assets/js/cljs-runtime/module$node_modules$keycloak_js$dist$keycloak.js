shadow$provide.module$node_modules$keycloak_js$dist$keycloak = function(global, require, module, exports) {
  var process = require("module$node_modules$process$browser");
  (function(global, factory) {
    "object" === typeof exports && "undefined" !== typeof module ? module.exports = factory(require("module$node_modules$crypto_browserify$index"), require("module$node_modules$buffer$index")) : "function" === typeof define && define.amd ? define("keycloak", ["crypto", "buffer"], factory) : (global = "undefined" !== typeof globalThis ? globalThis : global || self, global.Keycloak = factory(global.require$$0, global.require$$1));
  })(this, function(require$$0, require$$1) {
    function commonjsRequire(path) {
      throw Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    function b64DecodeUnicode(str) {
      return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {
        m = p.charCodeAt(0).toString(16).toUpperCase();
        2 > m.length && (m = "0" + m);
        return "%" + m;
      }));
    }
    function jwtDecode(token, options) {
      if ("string" !== typeof token) {
        throw new InvalidTokenError("Invalid token specified: must be a string");
      }
      options || (options = {});
      options = !0 === options.header ? 0 : 1;
      token = token.split(".")[options];
      if ("string" !== typeof token) {
        throw new InvalidTokenError(`Invalid token specified: missing part #${options + 1}`);
      }
      let decoded;
      try {
        {
          let output = token.replace(/-/g, "+").replace(/_/g, "/");
          switch(output.length % 4) {
            case 0:
              break;
            case 2:
              output += "\x3d\x3d";
              break;
            case 3:
              output += "\x3d";
              break;
            default:
              throw Error("base64 string is not of the correct length");
          }
          try {
            decoded = b64DecodeUnicode(output);
          } catch (err) {
            decoded = atob(output);
          }
        }
      } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${options + 1} (${e.message})`);
      }
      try {
        return JSON.parse(decoded);
      } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${options + 1} (${e.message})`);
      }
    }
    function Keycloak(config) {
      function generateRandomString(len, alphabet) {
        var crypto = window.crypto || window.msCrypto;
        if (crypto && crypto.getRandomValues && window.Uint8Array) {
          var randomData = new Uint8Array(len);
          crypto.getRandomValues(randomData);
        } else {
          for (randomData = Array(len), crypto = 0; crypto < randomData.length; crypto++) {
            randomData[crypto] = Math.floor(256 * Math.random());
          }
        }
        crypto = Array(len);
        for (var i = 0; i < len; i++) {
          crypto[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);
        }
        return String.fromCharCode.apply(null, crypto);
      }
      function getRealmUrl() {
        if ("undefined" !== typeof kc.authServerUrl) {
          return "/" == kc.authServerUrl.charAt(kc.authServerUrl.length - 1) ? kc.authServerUrl + "realms/" + encodeURIComponent(kc.realm) : kc.authServerUrl + "/realms/" + encodeURIComponent(kc.realm);
        }
      }
      function processCallback(oauth, promise) {
        function authSuccess(accessToken, refreshToken, idToken, fulfillPromise) {
          timeLocal = (timeLocal + (new Date()).getTime()) / 2;
          setToken(accessToken, refreshToken, idToken, timeLocal);
          useNonce && kc.idTokenParsed && kc.idTokenParsed.nonce != oauth.storedNonce ? (logInfo("[KEYCLOAK] Invalid nonce, clearing token"), kc.clearToken(), promise && promise.setError()) : fulfillPromise && (kc.onAuthSuccess && kc.onAuthSuccess(), promise && promise.setSuccess());
        }
        var code = oauth.code, error = oauth.error, prompt = oauth.prompt, timeLocal = (new Date()).getTime();
        oauth.kc_action_status && kc.onActionUpdate && kc.onActionUpdate(oauth.kc_action_status);
        if (error) {
          "none" != prompt ? (code = {error, error_description:oauth.error_description}, kc.onAuthError && kc.onAuthError(code), promise && promise.setError(code)) : promise && promise.setSuccess();
        } else if ("standard" != kc.flow && (oauth.access_token || oauth.id_token) && authSuccess(oauth.access_token, null, oauth.id_token, !0), "implicit" != kc.flow && code) {
          code = "code\x3d" + code + "\x26grant_type\x3dauthorization_code";
          error = kc.endpoints.token();
          var req = new XMLHttpRequest();
          req.open("POST", error, !0);
          req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
          code += "\x26client_id\x3d" + encodeURIComponent(kc.clientId);
          code += "\x26redirect_uri\x3d" + oauth.redirectUri;
          oauth.pkceCodeVerifier && (code += "\x26code_verifier\x3d" + oauth.pkceCodeVerifier);
          req.withCredentials = !0;
          req.onreadystatechange = function() {
            if (4 == req.readyState) {
              if (200 == req.status) {
                var tokenResponse = JSON.parse(req.responseText);
                authSuccess(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.id_token, "standard" === kc.flow);
                scheduleCheckIframe();
              } else {
                kc.onAuthError && kc.onAuthError(), promise && promise.setError();
              }
            }
          };
          req.send(code);
        }
      }
      function loadConfig(url) {
        function setupOidcEndoints(oidcConfiguration) {
          kc.endpoints = oidcConfiguration ? {authorize:function() {
            return oidcConfiguration.authorization_endpoint;
          }, token:function() {
            return oidcConfiguration.token_endpoint;
          }, logout:function() {
            if (!oidcConfiguration.end_session_endpoint) {
              throw "Not supported by the OIDC server";
            }
            return oidcConfiguration.end_session_endpoint;
          }, checkSessionIframe:function() {
            if (!oidcConfiguration.check_session_iframe) {
              throw "Not supported by the OIDC server";
            }
            return oidcConfiguration.check_session_iframe;
          }, register:function() {
            throw 'Redirection to "Register user" page not supported in standard OIDC mode';
          }, userinfo:function() {
            if (!oidcConfiguration.userinfo_endpoint) {
              throw "Not supported by the OIDC server";
            }
            return oidcConfiguration.userinfo_endpoint;
          }} : {authorize:function() {
            return getRealmUrl() + "/protocol/openid-connect/auth";
          }, token:function() {
            return getRealmUrl() + "/protocol/openid-connect/token";
          }, logout:function() {
            return getRealmUrl() + "/protocol/openid-connect/logout";
          }, checkSessionIframe:function() {
            var src = getRealmUrl() + "/protocol/openid-connect/login-status-iframe.html";
            kc.iframeVersion && (src = src + "?version\x3d" + kc.iframeVersion);
            return src;
          }, thirdPartyCookiesIframe:function() {
            var src = getRealmUrl() + "/protocol/openid-connect/3p-cookies/step1.html";
            kc.iframeVersion && (src = src + "?version\x3d" + kc.iframeVersion);
            return src;
          }, register:function() {
            return getRealmUrl() + "/protocol/openid-connect/registrations";
          }, userinfo:function() {
            return getRealmUrl() + "/protocol/openid-connect/userinfo";
          }};
        }
        var promise = createPromise(), configUrl;
        config ? "string" === typeof config && (configUrl = config) : configUrl = "keycloak.json";
        if (configUrl) {
          var req = new XMLHttpRequest();
          req.open("GET", configUrl, !0);
          req.setRequestHeader("Accept", "application/json");
          req.onreadystatechange = function() {
            if (4 == req.readyState) {
              if (200 == req.status || 0 == req.status && req.responseText && req.responseURL.startsWith("file:")) {
                var config = JSON.parse(req.responseText);
                kc.authServerUrl = config["auth-server-url"];
                kc.realm = config.realm;
                kc.clientId = config.resource;
                setupOidcEndoints(null);
                promise.setSuccess();
              } else {
                promise.setError();
              }
            }
          };
          req.send();
        } else {
          if (!config.clientId) {
            throw "clientId missing";
          }
          kc.clientId = config.clientId;
          if (url = config.oidcProvider) {
            "string" === typeof url ? (url = "/" == url.charAt(url.length - 1) ? url + ".well-known/openid-configuration" : url + "/.well-known/openid-configuration", req = new XMLHttpRequest(), req.open("GET", url, !0), req.setRequestHeader("Accept", "application/json"), req.onreadystatechange = function() {
              if (4 == req.readyState) {
                if (200 == req.status || 0 == req.status && req.responseText && req.responseURL.startsWith("file:")) {
                  var oidcProviderConfig = JSON.parse(req.responseText);
                  setupOidcEndoints(oidcProviderConfig);
                  promise.setSuccess();
                } else {
                  promise.setError();
                }
              }
            }, req.send()) : (setupOidcEndoints(url), promise.setSuccess());
          } else {
            if (!config.url) {
              for (url = document.getElementsByTagName("script"), configUrl = 0; configUrl < url.length; configUrl++) {
                if (url[configUrl].src.match(/.*keycloak\.js/)) {
                  config.url = url[configUrl].src.substr(0, url[configUrl].src.indexOf("/js/keycloak.js"));
                  break;
                }
              }
            }
            if (!config.realm) {
              throw "realm missing";
            }
            kc.authServerUrl = config.url;
            kc.realm = config.realm;
            setupOidcEndoints(null);
            promise.setSuccess();
          }
        }
        return promise.promise;
      }
      function setToken(token, refreshToken, idToken, timeLocal) {
        kc.tokenTimeoutHandle && (clearTimeout(kc.tokenTimeoutHandle), kc.tokenTimeoutHandle = null);
        refreshToken ? (kc.refreshToken = refreshToken, kc.refreshTokenParsed = jwtDecode(refreshToken)) : (delete kc.refreshToken, delete kc.refreshTokenParsed);
        idToken ? (kc.idToken = idToken, kc.idTokenParsed = jwtDecode(idToken)) : (delete kc.idToken, delete kc.idTokenParsed);
        if (token) {
          if (kc.token = token, kc.tokenParsed = jwtDecode(token), kc.sessionId = kc.tokenParsed.session_state, kc.authenticated = !0, kc.subject = kc.tokenParsed.sub, kc.realmAccess = kc.tokenParsed.realm_access, kc.resourceAccess = kc.tokenParsed.resource_access, timeLocal && (kc.timeSkew = Math.floor(timeLocal / 1000) - kc.tokenParsed.iat), null != kc.timeSkew && (logInfo("[KEYCLOAK] Estimated time difference between browser and server is " + kc.timeSkew + " seconds"), kc.onTokenExpired)) {
            if (token = 1000 * (kc.tokenParsed.exp - (new Date()).getTime() / 1000 + kc.timeSkew), logInfo("[KEYCLOAK] Token expires in " + Math.round(token / 1000) + " s"), 0 >= token) {
              kc.onTokenExpired();
            } else {
              kc.tokenTimeoutHandle = setTimeout(kc.onTokenExpired, token);
            }
          }
        } else {
          delete kc.token, delete kc.tokenParsed, delete kc.subject, delete kc.realmAccess, delete kc.resourceAccess, kc.authenticated = !1;
        }
      }
      function createUUID() {
        var s = generateRandomString(36, "0123456789abcdef").split("");
        s[14] = "4";
        s[19] = "0123456789abcdef".substr(s[19] & 3 | 8, 1);
        s[8] = s[13] = s[18] = s[23] = "-";
        return s.join("");
      }
      function parseCallback(url) {
        a: {
          switch(kc.flow) {
            case "standard":
              var supportedParams = ["code", "state", "session_state", "kc_action_status", "iss"];
              break;
            case "implicit":
              supportedParams = "access_token token_type id_token state session_state expires_in kc_action_status iss".split(" ");
              break;
            case "hybrid":
              supportedParams = "access_token token_type id_token code state session_state expires_in kc_action_status iss".split(" ");
          }
          supportedParams.push("error");
          supportedParams.push("error_description");
          supportedParams.push("error_uri");
          var queryIndex = url.indexOf("?"), fragmentIndex = url.indexOf("#");
          if ("query" === kc.responseMode && -1 !== queryIndex) {
            var newUrl = url.substring(0, queryIndex);
            var parsed = parseCallbackParams(url.substring(queryIndex + 1, -1 !== fragmentIndex ? fragmentIndex : url.length), supportedParams);
            "" !== parsed.paramsString && (newUrl += "?" + parsed.paramsString);
            -1 !== fragmentIndex && (newUrl += url.substring(fragmentIndex));
          } else {
            "fragment" === kc.responseMode && -1 !== fragmentIndex && (newUrl = url.substring(0, fragmentIndex), parsed = parseCallbackParams(url.substring(fragmentIndex + 1), supportedParams), "" !== parsed.paramsString && (newUrl += "#" + parsed.paramsString));
          }
          if (parsed && parsed.oauthParams) {
            if ("standard" === kc.flow || "hybrid" === kc.flow) {
              if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {
                parsed.oauthParams.newUrl = newUrl;
                url = parsed.oauthParams;
                break a;
              }
            } else if ("implicit" === kc.flow && (parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {
              parsed.oauthParams.newUrl = newUrl;
              url = parsed.oauthParams;
              break a;
            }
          }
          url = void 0;
        }
        if (url) {
          if (supportedParams = callbackStorage.get(url.state)) {
            url.valid = !0, url.redirectUri = supportedParams.redirectUri, url.storedNonce = supportedParams.nonce, url.prompt = supportedParams.prompt, url.pkceCodeVerifier = supportedParams.pkceCodeVerifier;
          }
          return url;
        }
      }
      function parseCallbackParams(paramsString, supportedParams) {
        paramsString = paramsString.split("\x26");
        for (var result = {paramsString:"", oauthParams:{}}, i = 0; i < paramsString.length; i++) {
          var split = paramsString[i].indexOf("\x3d"), key = paramsString[i].slice(0, split);
          -1 !== supportedParams.indexOf(key) ? result.oauthParams[key] = paramsString[i].slice(split + 1) : ("" !== result.paramsString && (result.paramsString += "\x26"), result.paramsString += paramsString[i]);
        }
        return result;
      }
      function createPromise() {
        var p = {setSuccess:function(result) {
          p.resolve(result);
        }, setError:function(result) {
          p.reject(result);
        }};
        p.promise = new es6Promise_minExports.Promise(function(resolve, reject) {
          p.resolve = resolve;
          p.reject = reject;
        });
        return p;
      }
      function applyTimeoutToPromise(promise, timeout, errorMessage) {
        var timeoutHandle = null, timeoutPromise = new es6Promise_minExports.Promise(function(resolve, reject) {
          timeoutHandle = setTimeout(function() {
            reject({error:errorMessage || "Promise is not settled within timeout of " + timeout + "ms"});
          }, timeout);
        });
        return es6Promise_minExports.Promise.race([promise, timeoutPromise]).finally(function() {
          clearTimeout(timeoutHandle);
        });
      }
      function setupCheckLoginIframe() {
        var promise = createPromise();
        if (!loginIframe.enable || loginIframe.iframe) {
          return promise.setSuccess(), promise.promise;
        }
        var iframe = document.createElement("iframe");
        loginIframe.iframe = iframe;
        iframe.onload = function() {
          var authUrl = kc.endpoints.authorize();
          "/" === authUrl.charAt(0) ? (authUrl = window.location.origin ? window.location.origin : window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : ""), loginIframe.iframeOrigin = authUrl) : loginIframe.iframeOrigin = authUrl.substring(0, authUrl.indexOf("/", 8));
          promise.setSuccess();
        };
        var src = kc.endpoints.checkSessionIframe();
        iframe.setAttribute("src", src);
        iframe.setAttribute("sandbox", "allow-storage-access-by-user-activation allow-scripts allow-same-origin");
        iframe.setAttribute("title", "keycloak-session-iframe");
        iframe.style.display = "none";
        document.body.appendChild(iframe);
        window.addEventListener("message", function(event) {
          if (event.origin === loginIframe.iframeOrigin && loginIframe.iframe.contentWindow === event.source && ("unchanged" == event.data || "changed" == event.data || "error" == event.data)) {
            "unchanged" != event.data && kc.clearToken();
            for (var callbacks = loginIframe.callbackList.splice(0, loginIframe.callbackList.length), i = callbacks.length - 1; 0 <= i; --i) {
              var promise = callbacks[i];
              "error" == event.data ? promise.setError() : promise.setSuccess("unchanged" == event.data);
            }
          }
        }, !1);
        return promise.promise;
      }
      function scheduleCheckIframe() {
        loginIframe.enable && kc.token && setTimeout(function() {
          checkLoginIframe().then(function(unchanged) {
            unchanged && scheduleCheckIframe();
          });
        }, 1000 * loginIframe.interval);
      }
      function checkLoginIframe() {
        var promise = createPromise();
        if (loginIframe.iframe && loginIframe.iframeOrigin) {
          var msg = kc.clientId + " " + (kc.sessionId ? kc.sessionId : "");
          loginIframe.callbackList.push(promise);
          var origin = loginIframe.iframeOrigin;
          1 == loginIframe.callbackList.length && loginIframe.iframe.contentWindow.postMessage(msg, origin);
        } else {
          promise.setSuccess();
        }
        return promise.promise;
      }
      function check3pCookiesSupported() {
        var promise = createPromise();
        if (loginIframe.enable || kc.silentCheckSsoRedirectUri) {
          var iframe = document.createElement("iframe");
          iframe.setAttribute("src", kc.endpoints.thirdPartyCookiesIframe());
          iframe.setAttribute("sandbox", "allow-storage-access-by-user-activation allow-scripts allow-same-origin");
          iframe.setAttribute("title", "keycloak-3p-check-iframe");
          iframe.style.display = "none";
          document.body.appendChild(iframe);
          var messageCallback = function(event) {
            iframe.contentWindow !== event.source || "supported" !== event.data && "unsupported" !== event.data || ("unsupported" === event.data && (logWarn("[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\n\n - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\n - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\n\nFor more information see: https://www.keycloak.org/docs/latest/securing_apps/#_modern_browsers"), 
            loginIframe.enable = !1, kc.silentCheckSsoFallback && (kc.silentCheckSsoRedirectUri = !1)), document.body.removeChild(iframe), window.removeEventListener("message", messageCallback), promise.setSuccess());
          };
          window.addEventListener("message", messageCallback, !1);
        } else {
          promise.setSuccess();
        }
        return applyTimeoutToPromise(promise.promise, kc.messageReceiveTimeout, "Timeout when waiting for 3rd party check iframe message.");
      }
      function loadAdapter(type) {
        if (!type || "default" == type) {
          return {login:function(options) {
            window.location.assign(kc.createLoginUrl(options));
            return createPromise().promise;
          }, logout:async function(options) {
            if ("GET" === (options?.logoutMethod ?? kc.logoutMethod)) {
              window.location.replace(kc.createLogoutUrl(options));
            } else {
              var logoutUrl = kc.createLogoutUrl(options);
              options = await fetch(logoutUrl, {method:"POST", headers:{"Content-Type":"application/x-www-form-urlencoded"}, body:new URLSearchParams({id_token_hint:kc.idToken, client_id:kc.clientId, post_logout_redirect_uri:adapter.redirectUri(options, !1)})});
              if (options.redirected) {
                window.location.href = options.url;
              } else {
                if (options.ok) {
                  window.location.reload();
                } else {
                  throw Error("Logout failed, request returned an error code.");
                }
              }
            }
          }, register:function(options) {
            window.location.assign(kc.createRegisterUrl(options));
            return createPromise().promise;
          }, accountManagement:function() {
            var accountUrl = kc.createAccountUrl();
            if ("undefined" !== typeof accountUrl) {
              window.location.href = accountUrl;
            } else {
              throw "Not supported by the OIDC server";
            }
            return createPromise().promise;
          }, redirectUri:function(options, encodeHash) {
            return options && options.redirectUri ? options.redirectUri : kc.redirectUri ? kc.redirectUri : location.href;
          }};
        }
        if ("cordova" == type) {
          loginIframe.enable = !1;
          var cordovaOpenWindowWrapper = function(loginUrl, target, options) {
            return window.cordova && window.cordova.InAppBrowser ? window.cordova.InAppBrowser.open(loginUrl, target, options) : window.open(loginUrl, target, options);
          }, shallowCloneCordovaOptions = function(userOptions) {
            return userOptions && userOptions.cordovaOptions ? Object.keys(userOptions.cordovaOptions).reduce(function(options, optionName) {
              options[optionName] = userOptions.cordovaOptions[optionName];
              return options;
            }, {}) : {};
          }, formatCordovaOptions = function(cordovaOptions) {
            return Object.keys(cordovaOptions).reduce(function(options, optionName) {
              options.push(optionName + "\x3d" + cordovaOptions[optionName]);
              return options;
            }, []).join(",");
          }, createCordovaOptions = function(userOptions) {
            var cordovaOptions = shallowCloneCordovaOptions(userOptions);
            cordovaOptions.location = "no";
            userOptions && "none" == userOptions.prompt && (cordovaOptions.hidden = "yes");
            return formatCordovaOptions(cordovaOptions);
          }, getCordovaRedirectUri = function() {
            return kc.redirectUri || "http://localhost";
          };
          return {login:function(options) {
            var promise = createPromise(), cordovaOptions = createCordovaOptions(options);
            options = kc.createLoginUrl(options);
            var ref = cordovaOpenWindowWrapper(options, "_blank", cordovaOptions), completed = !1, closed = !1;
            ref.addEventListener("loadstart", function(event) {
              0 == event.url.indexOf(getCordovaRedirectUri()) && (event = parseCallback(event.url), processCallback(event, promise), closed = !0, ref.close(), completed = !0);
            });
            ref.addEventListener("loaderror", function(event) {
              completed || (0 == event.url.indexOf(getCordovaRedirectUri()) ? (event = parseCallback(event.url), processCallback(event, promise), closed = !0, ref.close(), completed = !0) : (promise.setError(), closed = !0, ref.close()));
            });
            ref.addEventListener("exit", function(event) {
              closed || promise.setError({reason:"closed_by_user"});
            });
            return promise.promise;
          }, logout:function(options) {
            var promise = createPromise();
            options = kc.createLogoutUrl(options);
            var ref = cordovaOpenWindowWrapper(options, "_blank", "location\x3dno,hidden\x3dyes,clearcache\x3dyes"), error;
            ref.addEventListener("loadstart", function(event) {
              0 == event.url.indexOf(getCordovaRedirectUri()) && ref.close();
            });
            ref.addEventListener("loaderror", function(event) {
              0 != event.url.indexOf(getCordovaRedirectUri()) && (error = !0);
              ref.close();
            });
            ref.addEventListener("exit", function(event) {
              error ? promise.setError() : (kc.clearToken(), promise.setSuccess());
            });
            return promise.promise;
          }, register:function(options) {
            var promise = createPromise(), registerUrl = kc.createRegisterUrl();
            options = createCordovaOptions(options);
            var ref = cordovaOpenWindowWrapper(registerUrl, "_blank", options);
            ref.addEventListener("loadstart", function(event) {
              0 == event.url.indexOf(getCordovaRedirectUri()) && (ref.close(), event = parseCallback(event.url), processCallback(event, promise));
            });
            return promise.promise;
          }, accountManagement:function() {
            var accountUrl = kc.createAccountUrl();
            if ("undefined" !== typeof accountUrl) {
              var ref = cordovaOpenWindowWrapper(accountUrl, "_blank", "location\x3dno");
              ref.addEventListener("loadstart", function(event) {
                0 == event.url.indexOf(getCordovaRedirectUri()) && ref.close();
              });
            } else {
              throw "Not supported by the OIDC server";
            }
          }, redirectUri:function(options) {
            return getCordovaRedirectUri();
          }};
        }
        if ("cordova-native" == type) {
          return loginIframe.enable = !1, {login:function(options) {
            var promise = createPromise();
            options = kc.createLoginUrl(options);
            universalLinks.subscribe("keycloak", function(event) {
              universalLinks.unsubscribe("keycloak");
              window.cordova.plugins.browsertab.close();
              event = parseCallback(event.url);
              processCallback(event, promise);
            });
            window.cordova.plugins.browsertab.openUrl(options);
            return promise.promise;
          }, logout:function(options) {
            var promise = createPromise();
            options = kc.createLogoutUrl(options);
            universalLinks.subscribe("keycloak", function(event) {
              universalLinks.unsubscribe("keycloak");
              window.cordova.plugins.browsertab.close();
              kc.clearToken();
              promise.setSuccess();
            });
            window.cordova.plugins.browsertab.openUrl(options);
            return promise.promise;
          }, register:function(options) {
            var promise = createPromise();
            options = kc.createRegisterUrl(options);
            universalLinks.subscribe("keycloak", function(event) {
              universalLinks.unsubscribe("keycloak");
              window.cordova.plugins.browsertab.close();
              event = parseCallback(event.url);
              processCallback(event, promise);
            });
            window.cordova.plugins.browsertab.openUrl(options);
            return promise.promise;
          }, accountManagement:function() {
            var accountUrl = kc.createAccountUrl();
            if ("undefined" !== typeof accountUrl) {
              window.cordova.plugins.browsertab.openUrl(accountUrl);
            } else {
              throw "Not supported by the OIDC server";
            }
          }, redirectUri:function(options) {
            return options && options.redirectUri ? options.redirectUri : kc.redirectUri ? kc.redirectUri : "http://localhost";
          }};
        }
        throw "invalid adapter type: " + type;
      }
      function createLogger(fn) {
        return function() {
          kc.enableLogging && fn.apply(console, Array.prototype.slice.call(arguments));
        };
      }
      if (!(this instanceof Keycloak)) {
        throw Error("The 'Keycloak' constructor must be invoked with 'new'.");
      }
      for (var kc = this, adapter, refreshQueue = [], callbackStorage, loginIframe = {enable:!0, callbackList:[], interval:5}, scripts = document.getElementsByTagName("script"), i = 0; i < scripts.length; i++) {
        -1 === scripts[i].src.indexOf("keycloak.js") && -1 === scripts[i].src.indexOf("keycloak.min.js") || -1 === scripts[i].src.indexOf("version\x3d") || (kc.iframeVersion = scripts[i].src.substring(scripts[i].src.indexOf("version\x3d") + 8).split("\x26")[0]);
      }
      var useNonce = !0, logInfo = createLogger(console.info), logWarn = createLogger(console.warn);
      kc.init = function(initOptions) {
        function onLoad() {
          var doLogin = function(prompt) {
            prompt || (options.prompt = "none");
            initOptions && initOptions.locale && (options.locale = initOptions.locale);
            kc.login(options).then(function() {
              initPromise.setSuccess();
            }).catch(function(error) {
              initPromise.setError(error);
            });
          }, checkSsoSilently = function() {
            var ifrm = document.createElement("iframe"), src = kc.createLoginUrl({prompt:"none", redirectUri:kc.silentCheckSsoRedirectUri});
            ifrm.setAttribute("src", src);
            ifrm.setAttribute("sandbox", "allow-storage-access-by-user-activation allow-scripts allow-same-origin");
            ifrm.setAttribute("title", "keycloak-silent-check-sso");
            ifrm.style.display = "none";
            document.body.appendChild(ifrm);
            var messageCallback = function(event) {
              event.origin === window.location.origin && ifrm.contentWindow === event.source && (event = parseCallback(event.data), processCallback(event, initPromise), document.body.removeChild(ifrm), window.removeEventListener("message", messageCallback));
            };
            window.addEventListener("message", messageCallback);
          }, options = {};
          switch(initOptions.onLoad) {
            case "check-sso":
              loginIframe.enable ? setupCheckLoginIframe().then(function() {
                checkLoginIframe().then(function(unchanged) {
                  unchanged ? initPromise.setSuccess() : kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(!1);
                }).catch(function(error) {
                  initPromise.setError(error);
                });
              }) : kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(!1);
              break;
            case "login-required":
              doLogin(!0);
              break;
            default:
              throw "Invalid value for onLoad";
          }
        }
        function processInit() {
          var callback = parseCallback(window.location.href);
          callback && window.history.replaceState(window.history.state, null, callback.newUrl);
          if (callback && callback.valid) {
            return setupCheckLoginIframe().then(function() {
              processCallback(callback, initPromise);
            }).catch(function(error) {
              initPromise.setError(error);
            });
          }
          initOptions ? initOptions.token && initOptions.refreshToken ? (setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken), loginIframe.enable ? setupCheckLoginIframe().then(function() {
            checkLoginIframe().then(function(unchanged) {
              unchanged ? (kc.onAuthSuccess && kc.onAuthSuccess(), initPromise.setSuccess(), scheduleCheckIframe()) : initPromise.setSuccess();
            }).catch(function(error) {
              initPromise.setError(error);
            });
          }) : kc.updateToken(-1).then(function() {
            kc.onAuthSuccess && kc.onAuthSuccess();
            initPromise.setSuccess();
          }).catch(function(error) {
            kc.onAuthError && kc.onAuthError();
            initOptions.onLoad ? onLoad() : initPromise.setError(error);
          })) : initOptions.onLoad ? onLoad() : initPromise.setSuccess() : initPromise.setSuccess();
        }
        function domReady() {
          var promise = createPromise(), checkReadyState = function() {
            if ("interactive" === document.readyState || "complete" === document.readyState) {
              document.removeEventListener("readystatechange", checkReadyState), promise.setSuccess();
            }
          };
          document.addEventListener("readystatechange", checkReadyState);
          checkReadyState();
          return promise.promise;
        }
        if (kc.didInitialize) {
          throw Error("A 'Keycloak' instance can only be initialized once.");
        }
        kc.didInitialize = !0;
        kc.authenticated = !1;
        a: {
          try {
            callbackStorage = new LocalStorage();
            break a;
          } catch (err) {
          }
          callbackStorage = new CookieStorage();
        }
        var adapters = ["default", "cordova", "cordova-native"];
        adapter = initOptions && -1 < adapters.indexOf(initOptions.adapter) ? loadAdapter(initOptions.adapter) : initOptions && "object" === typeof initOptions.adapter ? initOptions.adapter : window.Cordova || window.cordova ? loadAdapter("cordova") : loadAdapter();
        if (initOptions) {
          "undefined" !== typeof initOptions.useNonce && (useNonce = initOptions.useNonce);
          "undefined" !== typeof initOptions.checkLoginIframe && (loginIframe.enable = initOptions.checkLoginIframe);
          initOptions.checkLoginIframeInterval && (loginIframe.interval = initOptions.checkLoginIframeInterval);
          "login-required" === initOptions.onLoad && (kc.loginRequired = !0);
          if (initOptions.responseMode) {
            if ("query" === initOptions.responseMode || "fragment" === initOptions.responseMode) {
              kc.responseMode = initOptions.responseMode;
            } else {
              throw "Invalid value for responseMode";
            }
          }
          if (initOptions.flow) {
            switch(initOptions.flow) {
              case "standard":
                kc.responseType = "code";
                break;
              case "implicit":
                kc.responseType = "id_token token";
                break;
              case "hybrid":
                kc.responseType = "code id_token token";
                break;
              default:
                throw "Invalid value for flow";
            }
            kc.flow = initOptions.flow;
          }
          null != initOptions.timeSkew && (kc.timeSkew = initOptions.timeSkew);
          initOptions.redirectUri && (kc.redirectUri = initOptions.redirectUri);
          initOptions.silentCheckSsoRedirectUri && (kc.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri);
          kc.silentCheckSsoFallback = "boolean" === typeof initOptions.silentCheckSsoFallback ? initOptions.silentCheckSsoFallback : !0;
          if (initOptions.pkceMethod) {
            if ("S256" !== initOptions.pkceMethod) {
              throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${initOptions.pkceMethod}'.`);
            }
            kc.pkceMethod = initOptions.pkceMethod;
          } else {
            kc.pkceMethod = "S256";
          }
          kc.enableLogging = "boolean" === typeof initOptions.enableLogging ? initOptions.enableLogging : !1;
          kc.logoutMethod = "POST" === initOptions.logoutMethod ? "POST" : "GET";
          "string" === typeof initOptions.scope && (kc.scope = initOptions.scope);
          "string" === typeof initOptions.acrValues && (kc.acrValues = initOptions.acrValues);
          kc.messageReceiveTimeout = "number" === typeof initOptions.messageReceiveTimeout && 0 < initOptions.messageReceiveTimeout ? initOptions.messageReceiveTimeout : 10000;
        }
        kc.responseMode || (kc.responseMode = "fragment");
        kc.responseType || (kc.responseType = "code", kc.flow = "standard");
        var promise = createPromise(), initPromise = createPromise();
        initPromise.promise.then(function() {
          kc.onReady && kc.onReady(kc.authenticated);
          promise.setSuccess(kc.authenticated);
        }).catch(function(error) {
          promise.setError(error);
        });
        adapters = loadConfig();
        adapters.then(function() {
          domReady().then(check3pCookiesSupported).then(processInit).catch(function(error) {
            promise.setError(error);
          });
        });
        adapters.catch(function(error) {
          promise.setError(error);
        });
        return promise.promise;
      };
      kc.login = function(options) {
        return adapter.login(options);
      };
      kc.createLoginUrl = function(options) {
        var state = createUUID(), nonce = createUUID(), redirectUri = adapter.redirectUri(options), callbackState = {state, nonce, redirectUri:encodeURIComponent(redirectUri)};
        options && options.prompt && (callbackState.prompt = options.prompt);
        var baseUrl = options && "register" == options.action ? kc.endpoints.register() : kc.endpoints.authorize();
        var scope = options && options.scope || kc.scope;
        scope ? -1 === scope.indexOf("openid") && (scope = "openid " + scope) : scope = "openid";
        state = baseUrl + "?client_id\x3d" + encodeURIComponent(kc.clientId) + "\x26redirect_uri\x3d" + encodeURIComponent(redirectUri) + "\x26state\x3d" + encodeURIComponent(state) + "\x26response_mode\x3d" + encodeURIComponent(kc.responseMode) + "\x26response_type\x3d" + encodeURIComponent(kc.responseType) + "\x26scope\x3d" + encodeURIComponent(scope);
        useNonce && (state = state + "\x26nonce\x3d" + encodeURIComponent(nonce));
        options && options.prompt && (state += "\x26prompt\x3d" + encodeURIComponent(options.prompt));
        options && options.maxAge && (state += "\x26max_age\x3d" + encodeURIComponent(options.maxAge));
        options && options.loginHint && (state += "\x26login_hint\x3d" + encodeURIComponent(options.loginHint));
        options && options.idpHint && (state += "\x26kc_idp_hint\x3d" + encodeURIComponent(options.idpHint));
        options && options.action && "register" != options.action && (state += "\x26kc_action\x3d" + encodeURIComponent(options.action));
        options && options.locale && (state += "\x26ui_locales\x3d" + encodeURIComponent(options.locale));
        options && options.acr && (nonce = JSON.stringify({id_token:{acr:options.acr}}), state += "\x26claims\x3d" + encodeURIComponent(nonce));
        if (options && options.acrValues || kc.acrValues) {
          state += "\x26acr_values\x3d" + encodeURIComponent(options.acrValues || kc.acrValues);
        }
        if (kc.pkceMethod) {
          options = generateRandomString(96, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
          callbackState.pkceCodeVerifier = options;
          nonce = kc.pkceMethod;
          if ("S256" !== nonce) {
            throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${nonce}'.`);
          }
          options = new Uint8Array(sha256.arrayBuffer(options));
          options = String.fromCodePoint(...options);
          options = btoa(options).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
          state = state + ("\x26code_challenge\x3d" + options) + ("\x26code_challenge_method\x3d" + kc.pkceMethod);
        }
        callbackStorage.add(callbackState);
        return state;
      };
      kc.logout = function(options) {
        return adapter.logout(options);
      };
      kc.createLogoutUrl = function(options) {
        if ("POST" === (options?.logoutMethod ?? kc.logoutMethod)) {
          return kc.endpoints.logout();
        }
        options = kc.endpoints.logout() + "?client_id\x3d" + encodeURIComponent(kc.clientId) + "\x26post_logout_redirect_uri\x3d" + encodeURIComponent(adapter.redirectUri(options, !1));
        kc.idToken && (options += "\x26id_token_hint\x3d" + encodeURIComponent(kc.idToken));
        return options;
      };
      kc.register = function(options) {
        return adapter.register(options);
      };
      kc.createRegisterUrl = function(options) {
        options || (options = {});
        options.action = "register";
        return kc.createLoginUrl(options);
      };
      kc.createAccountUrl = function(options) {
        var realm = getRealmUrl(), url = void 0;
        "undefined" !== typeof realm && (url = realm + "/account?referrer\x3d" + encodeURIComponent(kc.clientId) + "\x26referrer_uri\x3d" + encodeURIComponent(adapter.redirectUri(options)));
        return url;
      };
      kc.accountManagement = function() {
        return adapter.accountManagement();
      };
      kc.hasRealmRole = function(role) {
        var access = kc.realmAccess;
        return !!access && 0 <= access.roles.indexOf(role);
      };
      kc.hasResourceRole = function(role, resource) {
        if (!kc.resourceAccess) {
          return !1;
        }
        resource = kc.resourceAccess[resource || kc.clientId];
        return !!resource && 0 <= resource.roles.indexOf(role);
      };
      kc.loadUserProfile = function() {
        var url = getRealmUrl() + "/account", req = new XMLHttpRequest();
        req.open("GET", url, !0);
        req.setRequestHeader("Accept", "application/json");
        req.setRequestHeader("Authorization", "bearer " + kc.token);
        var promise = createPromise();
        req.onreadystatechange = function() {
          4 == req.readyState && (200 == req.status ? (kc.profile = JSON.parse(req.responseText), promise.setSuccess(kc.profile)) : promise.setError());
        };
        req.send();
        return promise.promise;
      };
      kc.loadUserInfo = function() {
        var url = kc.endpoints.userinfo(), req = new XMLHttpRequest();
        req.open("GET", url, !0);
        req.setRequestHeader("Accept", "application/json");
        req.setRequestHeader("Authorization", "bearer " + kc.token);
        var promise = createPromise();
        req.onreadystatechange = function() {
          4 == req.readyState && (200 == req.status ? (kc.userInfo = JSON.parse(req.responseText), promise.setSuccess(kc.userInfo)) : promise.setError());
        };
        req.send();
        return promise.promise;
      };
      kc.isTokenExpired = function(minValidity) {
        if (!kc.tokenParsed || !kc.refreshToken && "implicit" != kc.flow) {
          throw "Not authenticated";
        }
        if (null == kc.timeSkew) {
          return logInfo("[KEYCLOAK] Unable to determine if token is expired as timeskew is not set"), !0;
        }
        var expiresIn = kc.tokenParsed.exp - Math.ceil((new Date()).getTime() / 1000) + kc.timeSkew;
        if (minValidity) {
          if (isNaN(minValidity)) {
            throw "Invalid minValidity";
          }
          expiresIn -= minValidity;
        }
        return 0 > expiresIn;
      };
      kc.updateToken = function(minValidity) {
        var promise = createPromise();
        if (!kc.refreshToken) {
          return promise.setError(), promise.promise;
        }
        minValidity = minValidity || 5;
        var exec = function() {
          var refreshToken = !1;
          if (-1 == minValidity) {
            refreshToken = !0, logInfo("[KEYCLOAK] Refreshing token: forced refresh");
          } else if (!kc.tokenParsed || kc.isTokenExpired(minValidity)) {
            refreshToken = !0, logInfo("[KEYCLOAK] Refreshing token: token expired");
          }
          if (refreshToken) {
            refreshToken = "grant_type\x3drefresh_token\x26refresh_token\x3d" + kc.refreshToken;
            var url = kc.endpoints.token();
            refreshQueue.push(promise);
            if (1 == refreshQueue.length) {
              var req = new XMLHttpRequest();
              req.open("POST", url, !0);
              req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
              req.withCredentials = !0;
              refreshToken += "\x26client_id\x3d" + encodeURIComponent(kc.clientId);
              var timeLocal = (new Date()).getTime();
              req.onreadystatechange = function() {
                if (4 == req.readyState) {
                  if (200 == req.status) {
                    logInfo("[KEYCLOAK] Token refreshed");
                    timeLocal = (timeLocal + (new Date()).getTime()) / 2;
                    var tokenResponse = JSON.parse(req.responseText);
                    setToken(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.id_token, timeLocal);
                    kc.onAuthRefreshSuccess && kc.onAuthRefreshSuccess();
                    for (tokenResponse = refreshQueue.pop(); null != tokenResponse; tokenResponse = refreshQueue.pop()) {
                      tokenResponse.setSuccess(!0);
                    }
                  } else {
                    for (logWarn("[KEYCLOAK] Failed to refresh token"), 400 == req.status && kc.clearToken(), kc.onAuthRefreshError && kc.onAuthRefreshError(), tokenResponse = refreshQueue.pop(); null != tokenResponse; tokenResponse = refreshQueue.pop()) {
                      tokenResponse.setError(!0);
                    }
                  }
                }
              };
              req.send(refreshToken);
            }
          } else {
            promise.setSuccess(!1);
          }
        };
        loginIframe.enable ? checkLoginIframe().then(function() {
          exec();
        }).catch(function(error) {
          promise.setError(error);
        }) : exec();
        return promise.promise;
      };
      kc.clearToken = function() {
        kc.token && (setToken(null, null, null), kc.onAuthLogout && kc.onAuthLogout(), kc.loginRequired && kc.login());
      };
      var LocalStorage = function() {
        function clearExpired() {
          for (var time = (new Date()).getTime(), i = 0; i < localStorage.length; i++) {
            var key = localStorage.key(i);
            if (key && 0 == key.indexOf("kc-callback-")) {
              var value = localStorage.getItem(key);
              if (value) {
                try {
                  var expires = JSON.parse(value).expires;
                  (!expires || expires < time) && localStorage.removeItem(key);
                } catch (err) {
                  localStorage.removeItem(key);
                }
              }
            }
          }
        }
        if (!(this instanceof LocalStorage)) {
          return new LocalStorage();
        }
        localStorage.setItem("kc-test", "test");
        localStorage.removeItem("kc-test");
        this.get = function(state) {
          if (state) {
            state = "kc-callback-" + state;
            var value = localStorage.getItem(state);
            value && (localStorage.removeItem(state), value = JSON.parse(value));
            clearExpired();
            return value;
          }
        };
        this.add = function(state) {
          clearExpired();
          var key = "kc-callback-" + state.state;
          state.expires = (new Date()).getTime() + 36E5;
          localStorage.setItem(key, JSON.stringify(state));
        };
      }, CookieStorage = function() {
        if (!(this instanceof CookieStorage)) {
          return new CookieStorage();
        }
        this.get = function(state) {
          if (state) {
            a: {
              var value = "kc-callback-" + state + "\x3d";
              for (var ca = document.cookie.split(";"), i = 0; i < ca.length; i++) {
                for (var c = ca[i]; " " == c.charAt(0);) {
                  c = c.substring(1);
                }
                if (0 == c.indexOf(value)) {
                  value = c.substring(value.length, c.length);
                  break a;
                }
              }
              value = "";
            }
            setCookie("kc-callback-" + state, "", cookieExpiration(-100));
            if (value) {
              return JSON.parse(value);
            }
          }
        };
        this.add = function(state) {
          setCookie("kc-callback-" + state.state, JSON.stringify(state), cookieExpiration(60));
        };
        this.removeItem = function(key) {
          setCookie(key, "", cookieExpiration(-100));
        };
        var cookieExpiration = function(minutes) {
          var exp = new Date();
          exp.setTime(exp.getTime() + 6E4 * minutes);
          return exp;
        }, setCookie = function(key, value, expirationDate) {
          key = key + "\x3d" + value + "; expires\x3d" + expirationDate.toUTCString() + "; ";
          document.cookie = key;
        };
      };
    }
    var commonjsGlobal = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : {}, es6Promise_min = {exports:{}};
    (function(module, exports) {
      !function(t, e) {
        module.exports = e();
      }(commonjsGlobal, function() {
        function o() {
          return function() {
            return process.nextTick(a);
          };
        }
        function i() {
          return "undefined" != typeof U ? function() {
            U(a);
          } : c();
        }
        function s() {
          var t = 0, e = new H(a), n = document.createTextNode("");
          return e.observe(n, {characterData:!0}), function() {
            n.data = t = ++t % 2;
          };
        }
        function u() {
          var t = new MessageChannel();
          return t.port1.onmessage = a, function() {
            return t.port2.postMessage(0);
          };
        }
        function c() {
          var t = setTimeout;
          return function() {
            return t(a, 1);
          };
        }
        function a() {
          for (var t = 0; t < N; t += 2) {
            (0,Q[t])(Q[t + 1]), Q[t] = void 0, Q[t + 1] = void 0;
          }
          N = 0;
        }
        function f() {
          try {
            var t = Function("return this")().require("vertx");
            return U = t.runOnLoop || t.runOnContext, i();
          } catch (e) {
            return c();
          }
        }
        function l(t, e) {
          var n = this, r = new this.constructor(v);
          void 0 === r[V] && x(r);
          var o = n._state;
          if (o) {
            var i = arguments[o - 1];
            z(function() {
              return T(o, r, i, n._result);
            });
          } else {
            j(n, r, t, e);
          }
          return r;
        }
        function h(t) {
          if (t && "object" == typeof t && t.constructor === this) {
            return t;
          }
          var n = new this(v);
          return w(n, t), n;
        }
        function v() {
        }
        function _(t, e, n, r) {
          try {
            t.call(e, n, r);
          } catch (o) {
            return o;
          }
        }
        function y(t, e, n) {
          z(function(t) {
            var r = !1, o = _(n, e, function(n) {
              r || (r = !0, e !== n ? w(t, n) : A(t, n));
            }, function(e) {
              r || (r = !0, S(t, e));
            }, "Settle: " + (t._label || " unknown promise"));
            !r && o && (r = !0, S(t, o));
          }, t);
        }
        function m(t, e) {
          e._state === Z ? A(t, e._result) : e._state === $ ? S(t, e._result) : j(e, void 0, function(e) {
            return w(t, e);
          }, function(e) {
            return S(t, e);
          });
        }
        function b(t, n, r) {
          n.constructor === t.constructor && r === l && n.constructor.resolve === h ? m(t, n) : void 0 === r ? A(t, n) : "function" == typeof r ? y(t, n, r) : A(t, n);
        }
        function w(e$jscomp$0, n) {
          if (e$jscomp$0 === n) {
            S(e$jscomp$0, new TypeError("You cannot resolve a promise with itself"));
          } else {
            var e = typeof n;
            if (null === n || "object" !== e && "function" !== e) {
              A(e$jscomp$0, n);
            } else {
              e = void 0;
              try {
                e = n.then;
              } catch (o) {
                return void S(e$jscomp$0, o);
              }
              b(e$jscomp$0, n, e);
            }
          }
        }
        function g(t) {
          t._onerror && t._onerror(t._result);
          E(t);
        }
        function A(t, e) {
          t._state === X && (t._result = e, t._state = Z, 0 !== t._subscribers.length && z(E, t));
        }
        function S(t, e) {
          t._state === X && (t._state = $, t._result = e, z(g, t));
        }
        function j(t, e, n, r) {
          var o = t._subscribers, i = o.length;
          t._onerror = null;
          o[i] = e;
          o[i + Z] = n;
          o[i + $] = r;
          0 === i && t._state && z(E, t);
        }
        function E(t) {
          var e = t._subscribers, n = t._state;
          if (0 !== e.length) {
            for (var r, o, i = t._result, s = 0; s < e.length; s += 3) {
              r = e[s], o = e[s + n], r ? T(n, r, o, i) : o(i);
            }
            t._subscribers.length = 0;
          }
        }
        function T(t, n, r, o) {
          var i = "function" == typeof r, s = void 0, u = void 0, c = !0;
          if (i) {
            try {
              s = r(o);
            } catch (a) {
              c = !1, u = a;
            }
            if (n === s) {
              return void S(n, new TypeError("A promises callback cannot return that same promise."));
            }
          } else {
            s = o;
          }
          n._state !== X || (i && c ? w(n, s) : !1 === c ? S(n, u) : t === Z ? A(n, s) : t === $ && S(n, s));
        }
        function M(t, e) {
          try {
            e(function(e) {
              w(t, e);
            }, function(e) {
              S(t, e);
            });
          } catch (n) {
            S(t, n);
          }
        }
        function x(t) {
          t[V] = tt++;
          t._state = void 0;
          t._result = void 0;
          t._subscribers = [];
        }
        var K = void 0, L = K = Array.isArray ? Array.isArray : function(t) {
          return "[object Array]" === Object.prototype.toString.call(t);
        }, N = 0, U = void 0, W = void 0, z = function(t, e) {
          Q[N] = t;
          Q[N + 1] = e;
          N += 2;
          2 === N && (W ? W(a) : R());
        }, G = (K = "undefined" != typeof window ? window : void 0) || {}, H = G.MutationObserver || G.WebKitMutationObserver;
        G = "undefined" == typeof self && "undefined" != typeof process && "[object process]" === {}.toString.call(process);
        var J = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel, Q = Array(1E3), R = void 0;
        R = G ? o() : H ? s() : J ? u() : void 0 === K && "function" == typeof commonjsRequire ? f() : c();
        var V = Math.random().toString(36).substring(2), X = void 0, Z = 1, $ = 2, tt = 0, et = function() {
          function t(t, e) {
            this._instanceConstructor = t;
            this.promise = new t(v);
            this.promise[V] || x(this.promise);
            L(e) ? (this.length = e.length, this._remaining = e.length, this._result = Array(this.length), 0 === this.length ? A(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(e), 0 === this._remaining && A(this.promise, this._result))) : S(this.promise, Error("Array Methods must be provided an Array"));
          }
          return t.prototype._enumerate = function(t) {
            for (var e = 0; this._state === X && e < t.length; e++) {
              this._eachEntry(t[e], e);
            }
          }, t.prototype._eachEntry = function(t, e) {
            var n = this._instanceConstructor, r = n.resolve;
            if (r === h) {
              var i = r = void 0, s = !1;
              try {
                r = t.then;
              } catch (u) {
                s = !0, i = u;
              }
              r === l && t._state !== X ? this._settledAt(t._state, e, t._result) : "function" != typeof r ? (this._remaining--, this._result[e] = t) : n === nt ? (n = new n(v), s ? S(n, i) : b(n, t, r), this._willSettleAt(n, e)) : this._willSettleAt(new n(function(e) {
                return e(t);
              }), e);
            } else {
              this._willSettleAt(r(t), e);
            }
          }, t.prototype._settledAt = function(t, e, n) {
            var r = this.promise;
            r._state === X && (this._remaining--, t === $ ? S(r, n) : this._result[e] = n);
            0 === this._remaining && A(r, this._result);
          }, t.prototype._willSettleAt = function(t, e) {
            var n = this;
            j(t, void 0, function(t) {
              return n._settledAt(Z, e, t);
            }, function(t) {
              return n._settledAt($, e, t);
            });
          }, t;
        }(), nt = function() {
          function t(e) {
            this[V] = tt++;
            this._result = this._state = void 0;
            this._subscribers = [];
            if (v !== e) {
              if ("function" != typeof e) {
                throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
              }
              if (this instanceof t) {
                M(this, e);
              } else {
                throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
              }
            }
          }
          return t.prototype["catch"] = function(t) {
            return this.then(null, t);
          }, t.prototype["finally"] = function(t) {
            var r = this.constructor;
            return "function" == typeof t ? this.then(function(e) {
              return r.resolve(t()).then(function() {
                return e;
              });
            }, function(e) {
              return r.resolve(t()).then(function() {
                throw e;
              });
            }) : this.then(t, t);
          }, t;
        }();
        return nt.prototype.then = l, nt.all = function(t) {
          return (new et(this, t)).promise;
        }, nt.race = function(t) {
          var e = this;
          return new e(L(t) ? function(n, r) {
            for (var o = t.length, i = 0; i < o; i++) {
              e.resolve(t[i]).then(n, r);
            }
          } : function(t, e) {
            return e(new TypeError("You must pass an array to race."));
          });
        }, nt.resolve = h, nt.reject = function(t) {
          var n = new this(v);
          return S(n, t), n;
        }, nt._setScheduler = function(t) {
          W = t;
        }, nt._setAsap = function(t) {
          z = t;
        }, nt._asap = z, nt.polyfill = function() {
          var t = void 0;
          if ("undefined" != typeof commonjsGlobal) {
            t = commonjsGlobal;
          } else if ("undefined" != typeof self) {
            t = self;
          } else {
            try {
              t = Function("return this")();
            } catch (e) {
              throw Error("polyfill failed because global object is unavailable in this environment");
            }
          }
          var n = t.Promise;
          if (n) {
            var r = null;
            try {
              r = Object.prototype.toString.call(n.resolve());
            } catch (e) {
            }
            if ("[object Promise]" === r && !n.cast) {
              return;
            }
          }
          t.Promise = nt;
        }, nt.Promise = nt, nt;
      });
    })(es6Promise_min);
    var es6Promise_minExports = es6Promise_min.exports;
    es6Promise_min = {exports:{}};
    (function(module) {
      (function() {
        function Sha256(is224, sharedMemory) {
          sharedMemory ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          is224 ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225);
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = !1;
          this.first = !0;
          this.is224 = is224;
        }
        function HmacSha256(key, is224, sharedMemory) {
          var i = typeof key;
          if ("string" === i) {
            var bytes = [], length = key.length, index = 0;
            for (i = 0; i < length; ++i) {
              var code = key.charCodeAt(i);
              128 > code ? bytes[index++] = code : (2048 > code ? bytes[index++] = 192 | code >>> 6 : (55296 > code || 57344 <= code ? bytes[index++] = 224 | code >>> 12 : (code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023), bytes[index++] = 240 | code >>> 18, bytes[index++] = 128 | code >>> 12 & 63), bytes[index++] = 128 | code >>> 6 & 63), bytes[index++] = 128 | code & 63);
            }
            key = bytes;
          } else {
            if ("object" === i) {
              if (null === key) {
                throw Error("input is invalid type");
              }
              if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!(Array.isArray(key) || ARRAY_BUFFER && ArrayBuffer.isView(key))) {
                throw Error("input is invalid type");
              }
            } else {
              throw Error("input is invalid type");
            }
          }
          64 < key.length && (key = (new Sha256(is224, !0)).update(key).array());
          bytes = [];
          length = [];
          for (i = 0; 64 > i; ++i) {
            index = key[i] || 0, bytes[i] = 92 ^ index, length[i] = 54 ^ index;
          }
          Sha256.call(this, is224, sharedMemory);
          this.update(length);
          this.oKeyPad = bytes;
          this.inner = !0;
          this.sharedMemory = sharedMemory;
        }
        var WINDOW = "object" === typeof window, root = WINDOW ? window : {};
        root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
        WINDOW = !WINDOW && "object" === typeof self;
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && "object" === typeof process && process.versions && process.versions.node;
        NODE_JS ? root = commonjsGlobal : WINDOW && (root = self);
        WINDOW = !root.JS_SHA256_NO_COMMON_JS && module.exports;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && "undefined" !== typeof ArrayBuffer, HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 
        2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], OUTPUT_TYPES = ["hex", "array", "digest", 
        "arrayBuffer"], blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return "[object Array]" === Object.prototype.toString.call(obj);
          };
        }
        !ARRAY_BUFFER || !root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(obj) {
          return "object" === typeof obj && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        });
        var createOutputMethod = function(outputType, is224) {
          return function(message) {
            return (new Sha256(is224, !0)).update(message)[outputType]();
          };
        }, createMethod = function(is224) {
          var method = createOutputMethod("hex", is224);
          NODE_JS && (method = nodeWrap(method, is224));
          method.create = function() {
            return new Sha256(is224);
          };
          method.update = function(message) {
            return method.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method[type] = createOutputMethod(type, is224);
          }
          return method;
        }, nodeWrap = function(method, is224) {
          var Buffer = require$$1.Buffer, algorithm = is224 ? "sha224" : "sha256";
          var bufferFrom = Buffer.from && !root.JS_SHA256_NO_BUFFER_FROM ? Buffer.from : function(message) {
            return new Buffer(message);
          };
          return function(message) {
            if ("string" === typeof message) {
              return require$$0.createHash(algorithm).update(message, "utf8").digest("hex");
            }
            if (null === message || void 0 === message) {
              throw Error("input is invalid type");
            }
            message.constructor === ArrayBuffer && (message = new Uint8Array(message));
            return Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer ? require$$0.createHash(algorithm).update(bufferFrom(message)).digest("hex") : method(message);
          };
        }, createHmacOutputMethod = function(outputType, is224) {
          return function(key, message) {
            return (new HmacSha256(key, is224, !0)).update(message)[outputType]();
          };
        }, createHmacMethod = function(is224) {
          var method = createHmacOutputMethod("hex", is224);
          method.create = function(key) {
            return new HmacSha256(key, is224);
          };
          method.update = function(key, message) {
            return method.create(key).update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method[type] = createHmacOutputMethod(type, is224);
          }
          return method;
        };
        Sha256.prototype.update = function(message) {
          if (!this.finalized) {
            var type = typeof message;
            if ("string" !== type) {
              if ("object" === type) {
                if (null === message) {
                  throw Error("input is invalid type");
                }
                if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                  message = new Uint8Array(message);
                } else if (!(Array.isArray(message) || ARRAY_BUFFER && ArrayBuffer.isView(message))) {
                  throw Error("input is invalid type");
                }
              } else {
                throw Error("input is invalid type");
              }
              var notString = !0;
            }
            for (var index = 0, i, length = message.length, blocks = this.blocks; index < length;) {
              this.hashed && (this.hashed = !1, blocks[0] = this.block, this.block = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0);
              if (notString) {
                for (i = this.start; index < length && 64 > i; ++index) {
                  blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];
                }
              } else {
                for (i = this.start; index < length && 64 > i; ++index) {
                  type = message.charCodeAt(index), 128 > type ? blocks[i >>> 2] |= type << SHIFT[i++ & 3] : (2048 > type ? blocks[i >>> 2] |= (192 | type >>> 6) << SHIFT[i++ & 3] : (55296 > type || 57344 <= type ? blocks[i >>> 2] |= (224 | type >>> 12) << SHIFT[i++ & 3] : (type = 65536 + ((type & 1023) << 10 | message.charCodeAt(++index) & 1023), blocks[i >>> 2] |= (240 | type >>> 18) << SHIFT[i++ & 3], blocks[i >>> 2] |= (128 | type >>> 12 & 63) << SHIFT[i++ & 3]), blocks[i >>> 2] |= (128 | type >>> 
                  6 & 63) << SHIFT[i++ & 3]), blocks[i >>> 2] |= (128 | type & 63) << SHIFT[i++ & 3]);
                }
              }
              this.lastByteIndex = i;
              this.bytes += i - this.start;
              64 <= i ? (this.block = blocks[16], this.start = i - 64, this.hash(), this.hashed = !0) : this.start = i;
            }
            4294967295 < this.bytes && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes %= 4294967296);
            return this;
          }
        };
        Sha256.prototype.finalize = function() {
          if (!this.finalized) {
            this.finalized = !0;
            var blocks = this.blocks, i = this.lastByteIndex;
            blocks[16] = this.block;
            blocks[i >>> 2] |= EXTRA[i & 3];
            this.block = blocks[16];
            56 <= i && (this.hashed || this.hash(), blocks[0] = this.block, blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0);
            blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
            blocks[15] = this.bytes << 3;
            this.hash();
          }
        };
        Sha256.prototype.hash = function() {
          var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks = this.blocks, j;
          for (j = 16; 64 > j; ++j) {
            var s1 = blocks[j - 15];
            var s0 = (s1 >>> 7 | s1 << 25) ^ (s1 >>> 18 | s1 << 14) ^ s1 >>> 3;
            s1 = blocks[j - 2];
            s1 = (s1 >>> 17 | s1 << 15) ^ (s1 >>> 19 | s1 << 13) ^ s1 >>> 10;
            blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
          }
          var da = b & c;
          for (j = 0; 64 > j; j += 4) {
            if (this.first) {
              if (this.is224) {
                var ab = 300032;
                s1 = blocks[0] - 1413257819;
                h = s1 - 150054599 << 0;
                d = s1 + 24177077 << 0;
              } else {
                ab = 704751109, s1 = blocks[0] - 210244248, h = s1 - 1521486534 << 0, d = s1 + 143694565 << 0;
              }
              this.first = !1;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ab = a & b;
              var maj = ab ^ a & c ^ da;
              var ch = e & f ^ ~e & g;
              s1 = h + s1 + ch + K[j] + blocks[j];
              s0 += maj;
              h = d + s1 << 0;
              d = s1 + s0 << 0;
            }
            s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
            s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
            da = d & a;
            maj = da ^ d & b ^ ab;
            ch = h & e ^ ~h & f;
            s1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
            s0 += maj;
            g = c + s1 << 0;
            c = s1 + s0 << 0;
            s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
            s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
            ab = c & d;
            maj = ab ^ c & a ^ da;
            ch = g & h ^ ~g & e;
            s1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
            s0 += maj;
            f = b + s1 << 0;
            b = s1 + s0 << 0;
            s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
            s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
            da = b & c;
            maj = da ^ b & d ^ ab;
            ch = f & g ^ ~f & h;
            s1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
            s0 += maj;
            e = a + s1 << 0;
            a = s1 + s0 << 0;
            this.chromeBugWorkAround = !0;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
          this.h4 = this.h4 + e << 0;
          this.h5 = this.h5 + f << 0;
          this.h6 = this.h6 + g << 0;
          this.h7 = this.h7 + h << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          h0 = HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + 
          HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 
          12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >>> 28 & 15] + HEX_CHARS[h5 >>> 24 & 15] + HEX_CHARS[h5 >>> 20 & 15] + HEX_CHARS[h5 >>> 16 & 15] + HEX_CHARS[h5 >>> 12 & 15] + HEX_CHARS[h5 >>> 8 & 15] + HEX_CHARS[h5 >>> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >>> 28 & 15] + HEX_CHARS[h6 >>> 24 & 15] + HEX_CHARS[h6 >>> 20 & 15] + HEX_CHARS[h6 >>> 16 & 15] + HEX_CHARS[h6 >>> 12 & 15] + HEX_CHARS[h6 >>> 8 & 15] + HEX_CHARS[h6 >>> 4 & 15] + 
          HEX_CHARS[h6 & 15];
          this.is224 || (h0 += HEX_CHARS[h7 >>> 28 & 15] + HEX_CHARS[h7 >>> 24 & 15] + HEX_CHARS[h7 >>> 20 & 15] + HEX_CHARS[h7 >>> 16 & 15] + HEX_CHARS[h7 >>> 12 & 15] + HEX_CHARS[h7 >>> 8 & 15] + HEX_CHARS[h7 >>> 4 & 15] + HEX_CHARS[h7 & 15]);
          return h0;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          h0 = [h0 >>> 24 & 255, h0 >>> 16 & 255, h0 >>> 8 & 255, h0 & 255, h1 >>> 24 & 255, h1 >>> 16 & 255, h1 >>> 8 & 255, h1 & 255, h2 >>> 24 & 255, h2 >>> 16 & 255, h2 >>> 8 & 255, h2 & 255, h3 >>> 24 & 255, h3 >>> 16 & 255, h3 >>> 8 & 255, h3 & 255, h4 >>> 24 & 255, h4 >>> 16 & 255, h4 >>> 8 & 255, h4 & 255, h5 >>> 24 & 255, h5 >>> 16 & 255, h5 >>> 8 & 255, h5 & 255, h6 >>> 24 & 255, h6 >>> 16 & 255, h6 >>> 8 & 255, h6 & 255];
          this.is224 || h0.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
          return h0;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer = new ArrayBuffer(this.is224 ? 28 : 32), dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          this.is224 || dataView.setUint32(28, this.h7);
          return buffer;
        };
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = !1;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports = createMethod();
        exports.sha256 = exports;
        exports.sha224 = createMethod(!0);
        exports.sha256.hmac = createHmacMethod();
        exports.sha224.hmac = createHmacMethod(!0);
        WINDOW ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224);
      })();
    })(es6Promise_min);
    var sha256 = function(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }(es6Promise_min.exports);
    class InvalidTokenError extends Error {
    }
    InvalidTokenError.prototype.name = "InvalidTokenError";
    if ("undefined" === typeof es6Promise_minExports.Promise) {
      throw Error("Keycloak requires an environment that supports Promises. Make sure that you include the appropriate polyfill.");
    }
    return Keycloak;
  });
};

//# sourceMappingURL=module$node_modules$keycloak_js$dist$keycloak.js.map
